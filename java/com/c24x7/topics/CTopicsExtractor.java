/*
 * Copyright (C) 2010-2012 Patrick Nicolas
 */
package com.c24x7.topics;


import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import com.c24x7.math.utils.CFreqArray;
import com.c24x7.models.ATaxonomyNode;
import com.c24x7.models.CTaxonomyObject;
import com.c24x7.models.CText;
import com.c24x7.topics.CTopicsMap;
import com.c24x7.util.CEnv;
import com.c24x7.util.collections.CGraph;



			/**
			 * <p>Graph structure to record and organize elements of a taxonomy. A taxonomy
			 * is implemented as a graph which vertices are elements. <br>
			 * For instance  Albert Einstein (a 2-Gram of type NNP NNP) belongs to 
			 * "entity/physical entity/Object/Physical Object/living things/person/scientist"
			 * where entity, physical entity, Object... are elements.
			 * </p>
			 * @author Patrick Nicolas
			 * @date 01/13/2012
			 */

public final class CTopicsExtractor {	
	private static final double MIN_TOP_CLASS_WEIGHT = 0.2;

			/**
			 * <p>Inner class contains a matrix or double indexed table of taxonomy node
			 * and sentence indices for a particular class level.</p>
			 * 
			 * @author Patrick Nicolas         24x7c 
			 * @date June 1, 2012 9:10:30 PM
			 */
	protected class NTaxonomySentencesDistribution {
		protected Map<ATaxonomyNode, CFreqArray> _nodesSentencesMap = null;
		
		protected NTaxonomySentencesDistribution() {
			_nodesSentencesMap = new HashMap<ATaxonomyNode, CFreqArray>();
		}
			/**
			 * <p>Add a new taxonomy node and its associated array of sentences
			 * indices in the taxonomy table.</p>
			 * @param node taxonomy node added to the table
			 * @param sentenceIndices array of sentences indices
			 */
		protected void add(final ATaxonomyNode node, final CFreqArray newSentencesIndices) {
				/*
				 * If the taxonomy node is already defined in the table, 
				 * update the list of sentences indices
				 */
			CFreqArray sentencesIndices = null;
			if(_nodesSentencesMap.containsKey(node)) {
				sentencesIndices = _nodesSentencesMap.get(node);
				sentencesIndices.add(newSentencesIndices);
			}
				/*
				 * Otherwise add a new entry in the table.
				 */
			else {
				sentencesIndices = newSentencesIndices.clone();
				_nodesSentencesMap.put(node, sentencesIndices);
			}
		}
		
		
		protected final CFreqArray getSentencesIndices(final ATaxonomyNode node) {
			return _nodesSentencesMap.get(node);
		}
		
		/**
		 * <p>Display the indices of sentences associated with a specific taxonomy class.</p> 
		 * @return list of indices of sentences
		 */
		@Override
		public String toString() {
			StringBuilder buf = new StringBuilder();
				
			for( ATaxonomyNode node : _nodesSentencesMap.keySet()) {
				buf.append(node.getLabel());
				buf.append(": ");
				buf.append(node.getWeight());
				buf.append(": ");
				buf.append(_nodesSentencesMap.get(node).toString());
				buf.append("\n");
			}
		
			return buf.toString();
		}
	}


	
	
		/**
		 * <p>Define a model features for classifying taxonomy
		 * classes and retrieving the most relevant topics.</p>
		 * 
		 * @author Patrick Nicolas         24x7c 
		 * @date July 8, 2012 1:30:58 PM
		 */
	public final class NFeaturesSet  {
		private static final int NUM_FEATURES = 3;
		private double[]_values	= null;
	
		public NFeaturesSet() {
			_values = new double[NUM_FEATURES];
		}
		
		public NFeaturesSet(ATaxonomyNode tClass, double variance, int order) {
			_values = new double[NUM_FEATURES];
			_values[0] = tClass.getWeight();
			_values[1] = variance;
			_values[2] = order;
		}
		
		public double[] values() {
			return _values;
		}
		
		
		/**
		 * <p>Compute the maximum values for the model features within 
		 * a set or document.</p>
		 * @param featuresSet  new featuresSet generated by the document
		 */
		private void computeMaxValues(NFeaturesSet featuresSet) {
			if( featuresSet == null) {
				throw new IllegalArgumentException("Argument for computing FeaturesSet max values is incorrect");
			}
			double[] values = featuresSet.values();
			for( int k = 0; k < _values.length; k++) {
				if(_values[k] < values[k]) {
					_values[k] = values[k];
				}
			}
		}
		
		private void normalize() {
			double[] maxValues = _maxFeaturesValues.values();
			for( int k = 0; k < _values.length; k++) {
				_values[k] /= maxValues[k];
			}
		}

		
		public double getWeight() {
			return _values[0];
		}
		
		public double getVariance() {
			return _values[1];
		}
		
		public final double getOrder() {
			return _values[2];
		}

		
			/**
			 *<p>Textual representation of a topic model selection features which include
			 * taxonomy class weight, variance of the distribution of the class over the
			 * document and the order of the class within the lineage (or hierarchy of
			 * hypernyms).</p>
			 * @return taxonomy class label, weight, position variance and order.
			 */
		@Override
		public String toString() {
			StringBuilder buf = new StringBuilder();
			int lastIndex = _values.length-1;
			for( int k = 0; k < lastIndex; k++) {
				buf.append(_values[k]);
				buf.append(CEnv.FIELD_DELIM);
			}
			buf.append(_values[lastIndex]);
			
			return buf.toString();
		}

	}
	

	private NFeaturesSet _maxFeaturesValues 	= null;


		/**
		 * <p>Create a Topic extractor for a document document for which  
		 * a set of taxonomy classes have been extracted the number of taxonomy classes used in the
		 * extraction of topics is defined as NUM_TAXONOMY_CLASSES.</p>
		 */
	public CTopicsExtractor() {	}
	


	
			/**
			 * <p>Extracts the primary taxonomies from this document document using
			 * the taxonomy classifier.</p>
			 * 
			 * @param document document or text fragment, the most relevant topics have to be extracted from
			 * @return true if one primary taxonomy has been found, false otherwise
			 * @exception IllegalArgumentException if the document document is undefined.
			 */
	public boolean extract(CText document, CTopicsMap topicsMap, short textIndex) {
		if( document == null ) {
			throw new IllegalArgumentException("Cannot extract topics from an undefined document");
		}
	
		/*
		 * Create a map of topics extracted from a document.
		 */
		createTopicsMap(document, topicsMap);
		
		/*
		 * If the topics map is not empty, then create a 
		 * list of topic graph associated with top taxonomy classes.
		 */
		createGraphsList(topicsMap, textIndex);
		
		return true;
	}
	
		
	/**
	 * <p>Extract the values of the topic model features for a given document. This
	 * method is called by Topic model classifiers.</p>
	 * @param document document for which the features values or observations are extracted
	 * @param topicFeaturesMap map of the features values, using taxonomy class label as key
	 * @throws IllegalArgumentException if the document is undefined.
	 */
	public void getFeaturesList(final CText 				document, 
								Map<String, NFeaturesSet> 	topicFeaturesMap,
								CTopicsMap 					topicsMap) {
		if( document == null ) {
			throw new IllegalArgumentException("Cannot create an ontology for undefined document");
		}
		
		createTopicsMap(document, topicsMap);
				
		_maxFeaturesValues = new NFeaturesSet();
		Map<String, CTaxonomyObject> objectsMap = document.getObjectsMap();		
		
		CFreqArray sentencesIndices = null;
		List<ATaxonomyNode[]> taxonomyNodesList = null;
		
		NFeaturesSet feature = null;
		String taxonomyClassLabel = null;
		int classOrder = -1;
		
		/*
		 * Walks through the list of taxonomy instances or objects to
		 * extract/compute the features for the topics model.
		 */
		
		for( CTaxonomyObject taxonomyObject : objectsMap.values()) {
			taxonomyNodesList = taxonomyObject.getTaxonomyNodesList();

			/*
			 * Walks through the list of taxonomy node or classes associated
			 * with each taxonomy instance (or semantic N-Gram).
			 */
			if( taxonomyNodesList != null && taxonomyNodesList.size() > 0) {
				for(ATaxonomyNode[] taxonomyClasses : taxonomyNodesList) {					
					for( int k = 0; k < taxonomyClasses.length; k++) {
						taxonomyClassLabel = taxonomyClasses[k].getLabel();
						
						/*
						 * If the map of topic model features does not contain
						 * this taxonomy class label, then create a new feature value.
						 */
						if(!topicFeaturesMap.containsKey(taxonomyClassLabel)) {
							classOrder = taxonomyClasses.length - taxonomyClasses[k].getLevel();
							
							/*
							 * Create a new features set of values (or observations).
							 */
							sentencesIndices = topicsMap.getSentencesIndices( taxonomyClasses[k]);
							feature = new NFeaturesSet(taxonomyClasses[k], sentencesIndices.computeStats()[1], classOrder);
							topicFeaturesMap.put(taxonomyClassLabel, feature);
							_maxFeaturesValues.computeMaxValues(feature);
						}
					}
				}
			}
		}
		
		/*
		 * Normalize the values for all the observations
		 */
		for( NFeaturesSet featuresSet : topicFeaturesMap.values()) {
			featuresSet.normalize();
		}
	}



	
			// --------------------------
			// Private Supporting Methods
			// --------------------------



	private class NClassComparator implements Comparator<String> {
		Map<String, ATaxonomyNode> _map = null;
		
		public NClassComparator(Map<String, ATaxonomyNode> map) {
			_map = map;
		}
	
		/**
		 * <p>compare two Composite using their computed, normalized weights.
		 * This method is called for the ranking of the key taxonomyInstance nouns 
		 * in a document.</p>
		 * @param key1 content of the taxonomyInstance noun to compare from
		 * @param key2 content of the taxonomyInstance noun to compare to
		 */
		@Override
		public int compare(String label1, String label2) {
			return (_map.get(label1).getWeight() < _map.get(label2).getWeight() ? 1 : -1);
		}
	}


	
	private void createTopicsMap(final CText document, CTopicsMap topicsMap) {
		
		/*
		 * Walks through the list of taxonomy instances or objects to
		 * extract/compute the features for the topics model.
		 */
		List<ATaxonomyNode[]> taxonomyNodesList = null;
		Map<String, CTaxonomyObject> objectsMap = document.getObjectsMap();	
		
		/*
		 * Walk through the list of taxonomy objects..
		 */
		Map<String,ATaxonomyNode> topClassesMap = new HashMap<String,ATaxonomyNode>();
		NTaxonomySentencesDistribution taxonomyDistribution = new NTaxonomySentencesDistribution();
		 
		for( CTaxonomyObject taxonomyObject : objectsMap.values()) {	
			taxonomyNodesList = taxonomyObject.getTaxonomyNodesList();
	
			if( taxonomyNodesList != null && taxonomyNodesList.size() > 0) {
				for(ATaxonomyNode[] taxonomyClasses : taxonomyNodesList) {	
					topicsMap.addObject(taxonomyObject, taxonomyClasses, taxonomyDistribution);
					topClassesMap.put(taxonomyClasses[0].getLabel(), taxonomyClasses[0]);
				}
				
				/*
				 * Add this taxonomy instance to the topics map.
				 */
				topicsMap.addObject(taxonomyObject, taxonomyDistribution);
			}
		}
		
		@SuppressWarnings({ "unchecked", "rawtypes" })
		TreeMap<String, ATaxonomyNode> taxonomyClassesTreeMap = new TreeMap(new NClassComparator(topClassesMap));
		for(ATaxonomyNode topClass : topClassesMap.values()) {
			taxonomyClassesTreeMap.put(topClass.getLabel(), topClass);
		}
		
		
		/*
		 * Extract the most relevant top classes, which weight are greater 
		 * than a minimum threshold.
		 */
		Map<String, ATaxonomyNode> mostRelevantTopClassesMap = new HashMap<String, ATaxonomyNode>();
		for( String topClassLabel : taxonomyClassesTreeMap.keySet()) {
			if(topClassesMap.get(topClassLabel).getWeight() < MIN_TOP_CLASS_WEIGHT) {
				break;
			}
			mostRelevantTopClassesMap.put(topClassLabel, topClassesMap.get(topClassLabel));
		}
		

		/*
		 * Generate topics map for the relevant top classes and 
		 * taxonomy objects (semantic N-Grams) associated with this document.
		 */
		topicsMap.generateTopicsMap(objectsMap, mostRelevantTopClassesMap, taxonomyDistribution);
	}
	
	
	
	private void createGraphsList(CTopicsMap topicsMap, short textIndex) {
		if( !topicsMap.isEmpty() ) {
			List<CGraph> graphsList = new LinkedList<CGraph>();
		
			String rootLabel = null;
			
			List<Set<ATaxonomyNode[]>> taxonomyPathSetsList = topicsMap.getTaxonomyPathSets();
			
			for( Set<ATaxonomyNode[]> taxonomyPathsSet : taxonomyPathSetsList) {
				
				CGraph graph = null;
				for( ATaxonomyNode[] taxonomyPath : taxonomyPathsSet) {
					if(graph == null) {
						rootLabel = taxonomyPath[0].getLabel();
						graph = new CGraph(rootLabel);
					}
					
					graph.addVertices(taxonomyPath);
					for( ATaxonomyNode node : taxonomyPath) {
						node.setTextIndex(textIndex);
						
					}
				}
				graphsList.add(graph);
			}
			
			topicsMap.setGraphsList(graphsList);
		}
	}

}

// -------------------------  EOF ---------------------------------
